package employee

import (
	"backend/database"
	"net/http"

	"github.com/gin-gonic/gin"
)

// GetCourseTypeScores è·å–è¯¾ç¨‹ç±»å‹æˆç»©åˆ†æ
func GetCourseTypeScores(c *gin.Context) {
	// ä»ä¸­é—´ä»¶è·å–ç”¨æˆ·ID
	personID, exists := c.Get("personId")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"code": 401, "message": "æœªç™»å½?, "data": nil})
		return
	}

	// æŸ¥è¯¢ç”¨æˆ·å§“å
	var personName string
	database.DB.Raw("SELECT name FROM person WHERE person_id = ?", personID).Scan(&personName)

	// æŸ¥è¯¢å„è¯¾ç¨‹ç±»å‹çš„æˆç»©ç»Ÿè®¡
	rows, err := database.DB.Raw(`
		SELECT 
			c.course_class,
			COUNT(*) AS course_count,
			AVG(CASE 
				WHEN ae.teacher_score IS NOT NULL THEN 
					ae.self_score * (1 - ae.score_ratio) + ae.teacher_score * ae.score_ratio
				ELSE ae.self_score
			END) AS average_score,
			MAX(CASE 
				WHEN ae.teacher_score IS NOT NULL THEN 
					ae.self_score * (1 - ae.score_ratio) + ae.teacher_score * ae.score_ratio
				ELSE ae.self_score
			END) AS max_score,
			MIN(CASE 
				WHEN ae.teacher_score IS NOT NULL THEN 
					ae.self_score * (1 - ae.score_ratio) + ae.teacher_score * ae.score_ratio
				ELSE ae.self_score
			END) AS min_score
		FROM attendance_evaluation ae
		JOIN plan_course_item pci ON ae.item_id = pci.item_id
		JOIN course c ON pci.course_id = c.course_id
		WHERE ae.person_id = ? AND ae.self_score IS NOT NULL
		GROUP BY c.course_class
		ORDER BY average_score DESC
	`, personID).Rows()

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "æŸ¥è¯¢å¤±è´¥", "data": nil})
		return
	}
	defer rows.Close()

	// è§£æç»“æœ
	var courseTypeScores []map[string]interface{}
	var indicators []map[string]interface{}
	var values []float64

	for rows.Next() {
		var (
			courseClass  string
			courseCount  int
			averageScore float64
			maxScore     float64
			minScore     float64
		)

		rows.Scan(&courseClass, &courseCount, &averageScore, &maxScore, &minScore)

		courseTypeScore := map[string]interface{}{
			"courseClass":  courseClass,
			"courseCount":  courseCount,
			"averageScore": averageScore,
			"maxScore":     maxScore,
			"minScore":     minScore,
		}
		courseTypeScores = append(courseTypeScores, courseTypeScore)

		// ä¸ºé›·è¾¾å›¾å‡†å¤‡æ•°æ®
		indicators = append(indicators, map[string]interface{}{
			"name": courseClass,
			"max":  100,
		})
		values = append(values, averageScore)
	}

	// å¦‚æœæ²¡æœ‰æ•°æ®
	if len(courseTypeScores) == 0 {
		c.JSON(http.StatusOK, gin.H{
			"code":    200,
			"message": "æš‚æ— æˆç»©æ•°æ®",
			"data": gin.H{
				"personId":         personID,
				"personName":       personName,
				"courseTypeScores": []interface{}{},
				"radarData": gin.H{
					"indicators": []interface{}{},
					"values":     []interface{}{},
				},
			},
		})
		return
	}

	// è¿”å›ç»“æœ
	c.JSON(http.StatusOK, gin.H{
		"code":    200,
		"message": "è·å–æˆåŠŸ",
		"data": gin.H{
			"personId":         personID,
			"personName":       personName,
			"courseTypeScores": courseTypeScores,
			"radarData": gin.H{
				"indicators": indicators,
				"values":     values,
			},
		},
	})
}

package employee

import (
	"backend/database"
	"net/http"

	"github.com/gin-gonic/gin"
)

// GetLearningProgress è·å–å‘˜å·¥å­¦ä¹ è¿›åº¦
func GetLearningProgress(c *gin.Context) {
	// ä»ä¸­é—´ä»¶è·å–ç”¨æˆ·ID
	personID, exists := c.Get("personId")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"code": 401, "message": "æœªç™»å½?, "data": nil})
		return
	}

	// æŸ¥è¯¢ç”¨æˆ·å§“å
	var personName string
	database.DB.Raw("SELECT name FROM person WHERE person_id = ?", personID).Scan(&personName)

	// æŸ¥è¯¢æ•´ä½“è¿›åº¦
	var (
		totalPlans        int
		totalCourses      int
		completedCourses  int
		evaluatedCourses  int
		averageScore      float64
	)

	// å‚ä¸çš„åŸ¹è®­è®¡åˆ’æ€»æ•°
	database.DB.Raw(`
		SELECT COUNT(DISTINCT plan_id) FROM plan_employee WHERE person_id = ?
	`, personID).Scan(&totalPlans)

	// æ€»è¯¾ç¨‹æ•°ï¼ˆå·²ä¸Šè¿‡çš„ï¼‰
	database.DB.Raw(`
		SELECT COUNT(*)
		FROM plan_employee pe
		JOIN plan_course_item pci ON pe.plan_id = pci.plan_id
		WHERE pe.person_id = ? AND pci.class_date < CURDATE()
	`, personID).Scan(&totalCourses)

	// å·²å®Œæˆè¯¾ç¨‹æ•°ï¼ˆæœ‰è‡ªè¯„æˆ–è®²å¸ˆè¯„åˆ†çš„ï¼?
	database.DB.Raw(`
		SELECT COUNT(*)
		FROM attendance_evaluation ae
		JOIN plan_course_item pci ON ae.item_id = pci.item_id
		WHERE ae.person_id = ? AND (ae.self_score IS NOT NULL OR ae.teacher_score IS NOT NULL)
	`, personID).Scan(&completedCourses)

	// å·²è‡ªè¯„è¯¾ç¨‹æ•°
	database.DB.Raw(`
		SELECT COUNT(*)
		FROM attendance_evaluation 
		WHERE person_id = ? AND self_score IS NOT NULL
	`, personID).Scan(&evaluatedCourses)

	// å¹³å‡åˆ?
	database.DB.Raw(`
		SELECT AVG(CASE 
			WHEN teacher_score IS NOT NULL THEN 
				self_score * (1 - score_ratio) + teacher_score * score_ratio
			ELSE self_score
		END)
		FROM attendance_evaluation 
		WHERE person_id = ? AND self_score IS NOT NULL
	`, personID).Scan(&averageScore)

	// è®¡ç®—å®Œæˆç™¾åˆ†æ¯?
	progressPercentage := 0.0
	if totalCourses > 0 {
		progressPercentage = float64(completedCourses) / float64(totalCourses) * 100
	}

	// æŸ¥è¯¢å„è®¡åˆ’çš„è¿›åº¦
	planRows, err := database.DB.Raw(`
		SELECT 
			tp.plan_id,
			tp.plan_name,
			tp.plan_status,
			COUNT(DISTINCT pci.item_id) AS total_courses,
			COUNT(DISTINCT ae.item_id) AS completed_courses,
			AVG(CASE 
				WHEN ae.teacher_score IS NOT NULL THEN 
					ae.self_score * (1 - ae.score_ratio) + ae.teacher_score * ae.score_ratio
				ELSE ae.self_score
			END) AS average_score
		FROM plan_employee pe
		JOIN training_plan tp ON pe.plan_id = tp.plan_id
		LEFT JOIN plan_course_item pci ON tp.plan_id = pci.plan_id AND pci.class_date < CURDATE()
		LEFT JOIN attendance_evaluation ae ON ae.item_id = pci.item_id AND ae.person_id = ?
		WHERE pe.person_id = ?
		GROUP BY tp.plan_id, tp.plan_name, tp.plan_status
		ORDER BY tp.plan_start_datetime DESC
	`, personID, personID).Rows()

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "æŸ¥è¯¢è®¡åˆ’è¿›åº¦å¤±è´¥", "data": nil})
		return
	}
	defer planRows.Close()

	var planProgress []map[string]interface{}
	for planRows.Next() {
		var (
			planID           int64
			planName         string
			planStatus       string
			planTotalCourses int
			planCompleted    int
			planAvgScore     *float64
		)

		planRows.Scan(&planID, &planName, &planStatus, &planTotalCourses, &planCompleted, &planAvgScore)

		planProgressPercentage := 0.0
		if planTotalCourses > 0 {
			planProgressPercentage = float64(planCompleted) / float64(planTotalCourses) * 100
		}

		avgScore := 0.0
		if planAvgScore != nil {
			avgScore = *planAvgScore
		}

		plan := map[string]interface{}{
			"planId":              planID,
			"planName":            planName,
			"planStatus":          planStatus,
			"totalCourses":        planTotalCourses,
			"completedCourses":    planCompleted,
			"progressPercentage":  planProgressPercentage,
			"averageScore":        avgScore,
		}
		planProgress = append(planProgress, plan)
	}

	// æŸ¥è¯¢æœ€è¿?æ¡å­¦ä¹ è®°å½?
	recentRows, err := database.DB.Raw(`
		SELECT 
			pci.item_id,
			pci.course_id,
			c.course_name,
			pci.class_date,
			CASE 
				WHEN ae.person_id IS NOT NULL THEN true
				ELSE false
			END AS has_evaluated
		FROM plan_employee pe
		JOIN plan_course_item pci ON pe.plan_id = pci.plan_id
		JOIN course c ON pci.course_id = c.course_id
		LEFT JOIN attendance_evaluation ae ON ae.item_id = pci.item_id AND ae.person_id = ?
		WHERE pe.person_id = ? AND pci.class_date < CURDATE()
		ORDER BY pci.class_date DESC
		LIMIT 5
	`, personID, personID).Rows()

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "æŸ¥è¯¢æœ€è¿‘è¯¾ç¨‹å¤±è´?, "data": nil})
		return
	}
	defer recentRows.Close()

	var recentCourses []map[string]interface{}
	for recentRows.Next() {
		var (
			itemID       int64
			courseID     int64
			courseName   string
			classDate    string
			hasEvaluated bool
		)

		recentRows.Scan(&itemID, &courseID, &courseName, &classDate, &hasEvaluated)

		recent := map[string]interface{}{
			"itemId":       itemID,
			"courseId":     courseID,
			"courseName":   courseName,
			"classDate":    classDate,
			"hasEvaluated": hasEvaluated,
		}
		recentCourses = append(recentCourses, recent)
	}

	// è¿”å›ç»“æœ
	c.JSON(http.StatusOK, gin.H{
		"code":    200,
		"message": "è·å–æˆåŠŸ",
		"data": gin.H{
			"personId":   personID,
			"personName": personName,
			"overallProgress": gin.H{
				"totalPlans":         totalPlans,
				"totalCourses":       totalCourses,
				"completedCourses":   completedCourses,
				"evaluatedCourses":   evaluatedCourses,
				"progressPercentage": progressPercentage,
				"averageScore":       averageScore,
			},
			"planProgress":   planProgress,
			"recentCourses":  recentCourses,
		},
	})
}

package employee

import (
	"backend/database"
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
)

// GetPendingEvaluations è·å–å¾…è‡ªè¯„è¯¾ç¨‹åˆ—è¡?
func GetPendingEvaluations(c *gin.Context) {
	// ä»ä¸­é—´ä»¶è·å–ç”¨æˆ·ID
	personID, exists := c.Get("personId")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"code": 401, "message": "æœªç™»å½?, "data": nil})
		return
	}

	// è·å–æŸ¥è¯¢å‚æ•°
	status := c.DefaultQuery("status", "pending") // pending æˆ?all
	limitStr := c.DefaultQuery("limit", "0")      // 0è¡¨ç¤ºä¸é™åˆ?
	limit, _ := strconv.Atoi(limitStr)

	// æ„å»ºWHEREæ¡ä»¶
	whereClause := ""
	if status == "pending" {
		whereClause = "AND ae.person_id IS NULL" // æœªè‡ªè¯?
	}

	// æ„å»ºLIMITæ¡ä»¶
	limitClause := ""
	if limit > 0 {
		limitClause = " LIMIT " + limitStr
	}

	// æŸ¥è¯¢è¯¾ç¨‹ï¼ˆå·²ä¸Šå®Œçš„è¯¾ç¨‹ï¼‰
	query := `
		SELECT 
			pci.item_id,
			pci.course_id,
			c.course_name,
			c.course_desc,
			c.course_class,
			pci.class_date,
			pci.class_begin_time,
			pci.class_end_time,
			pci.location,
			pci.plan_id,
			tp.plan_name,
			c.teacher_id,
			p.name AS teacher_name,
			CASE 
				WHEN ae.person_id IS NOT NULL THEN 'evaluated'
				ELSE 'pending'
			END AS evaluation_status
		FROM plan_employee pe
		JOIN plan_course_item pci ON pe.plan_id = pci.plan_id
		JOIN course c ON pci.course_id = c.course_id
		JOIN training_plan tp ON pci.plan_id = tp.plan_id
		JOIN person p ON c.teacher_id = p.person_id
		LEFT JOIN attendance_evaluation ae ON ae.item_id = pci.item_id AND ae.person_id = ?
		WHERE pe.person_id = ? 
			AND pci.class_date < CURDATE()
			` + whereClause + `
		ORDER BY pci.class_date DESC
	` + limitClause

	rows, err := database.DB.Raw(query, personID, personID).Rows()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "æŸ¥è¯¢å¤±è´¥", "data": nil})
		return
	}
	defer rows.Close()

	// è§£æç»“æœ
	var courses []map[string]interface{}
	pendingCount := 0

	for rows.Next() {
		var (
			itemID           int64
			courseID         int64
			courseName       string
			courseDesc       string
			courseClass      string
			classDate        string
			classBeginTime   string
			classEndTime     string
			location         string
			planID           int64
			planName         string
			teacherID        int64
			teacherName      string
			evaluationStatus string
		)

		rows.Scan(
			&itemID, &courseID, &courseName, &courseDesc, &courseClass,
			&classDate, &classBeginTime, &classEndTime, &location,
			&planID, &planName, &teacherID, &teacherName, &evaluationStatus,
		)

		if evaluationStatus == "pending" {
			pendingCount++
		}

		course := map[string]interface{}{
			"itemId":           itemID,
			"courseId":         courseID,
			"courseName":       courseName,
			"courseDesc":       courseDesc,
			"courseClass":      courseClass,
			"classDate":        classDate,
			"classBeginTime":   classBeginTime,
			"classEndTime":     classEndTime,
			"location":         location,
			"planId":           planID,
			"planName":         planName,
			"teacherId":        teacherID,
			"teacherName":      teacherName,
			"evaluationStatus": evaluationStatus,
		}
		courses = append(courses, course)
	}

	// å¦‚æœæ²¡æœ‰è®¾ç½®limitï¼ŒtotalCountç­‰äºcoursesé•¿åº¦
	totalCount := len(courses)
	if limit > 0 && status == "all" {
		// éœ€è¦æŸ¥è¯¢æ€»æ•°
		var count int64
		database.DB.Raw(`
			SELECT COUNT(*)
			FROM plan_employee pe
			JOIN plan_course_item pci ON pe.plan_id = pci.plan_id
			WHERE pe.person_id = ? AND pci.class_date < CURDATE()
		`, personID).Scan(&count)
		totalCount = int(count)
	}

	// è¿”å›ç»“æœ
	c.JSON(http.StatusOK, gin.H{
		"code":    200,
		"message": "è·å–æˆåŠŸ",
		"data": gin.H{
			"totalCount":   totalCount,
			"pendingCount": pendingCount,
			"courses":      courses,
		},
	})
}

package employee

import (
	"backend/database"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
)

// GetSchedule è·å–å‘˜å·¥è¯¾ç¨‹è¡?
func GetSchedule(c *gin.Context) {
	// ä»ä¸­é—´ä»¶è·å–ç”¨æˆ·ID
	personID, exists := c.Get("personId")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"code": 401, "message": "æœªç™»å½?, "data": nil})
		return
	}

	// è·å–æŸ¥è¯¢å‚æ•°
	startDate := c.Query("startDate")
	endDate := c.Query("endDate")

	// éªŒè¯æ—¥æœŸå‚æ•°
	if startDate == "" || endDate == "" {
		c.JSON(http.StatusBadRequest, gin.H{"code": 400, "message": "æ—¥æœŸå‚æ•°é”™è¯¯", "data": nil})
		return
	}

	// éªŒè¯æ—¥æœŸæ ¼å¼
	_, err1 := time.Parse("2006-01-02", startDate)
	_, err2 := time.Parse("2006-01-02", endDate)
	if err1 != nil || err2 != nil {
		c.JSON(http.StatusBadRequest, gin.H{"code": 400, "message": "æ—¥æœŸæ ¼å¼é”™è¯¯ï¼Œåº”ä¸ºYYYY-MM-DD", "data": nil})
		return
	}

	// æŸ¥è¯¢è¯¾ç¨‹è¡?
	rows, err := database.DB.Raw(`
		SELECT 
			pci.item_id,
			pci.course_id,
			c.course_name,
			c.course_desc,
			c.course_class,
			pci.class_date,
			pci.class_begin_time,
			pci.class_end_time,
			pci.location,
			pci.plan_id,
			tp.plan_name,
			c.teacher_id,
			p.name AS teacher_name,
			CASE 
				WHEN ae.person_id IS NOT NULL THEN true 
				ELSE false 
			END AS has_evaluated
		FROM plan_employee pe
		JOIN plan_course_item pci ON pe.plan_id = pci.plan_id
		JOIN course c ON pci.course_id = c.course_id
		JOIN training_plan tp ON pci.plan_id = tp.plan_id
		JOIN person p ON c.teacher_id = p.person_id
		LEFT JOIN attendance_evaluation ae ON ae.item_id = pci.item_id AND ae.person_id = ?
		WHERE pe.person_id = ? 
			AND pci.class_date >= ? 
			AND pci.class_date <= ?
		ORDER BY pci.class_date ASC, pci.class_begin_time ASC
	`, personID, personID, startDate, endDate).Rows()

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "æŸ¥è¯¢å¤±è´¥", "data": nil})
		return
	}
	defer rows.Close()

	// æŒ‰æ—¥æœŸç»„ç»‡è¯¾ç¨?
	scheduleMap := make(map[string][]map[string]interface{})
	totalCourses := 0

	for rows.Next() {
		var (
			itemID         int64
			courseID       int64
			courseName     string
			courseDesc     string
			courseClass    string
			classDate      string
			classBeginTime string
			classEndTime   string
			location       string
			planID         int64
			planName       string
			teacherID      int64
			teacherName    string
			hasEvaluated   bool
		)

		rows.Scan(
			&itemID, &courseID, &courseName, &courseDesc, &courseClass,
			&classDate, &classBeginTime, &classEndTime, &location,
			&planID, &planName, &teacherID, &teacherName, &hasEvaluated,
		)

		course := map[string]interface{}{
			"itemId":         itemID,
			"courseId":       courseID,
			"courseName":     courseName,
			"courseDesc":     courseDesc,
			"courseClass":    courseClass,
			"classBeginTime": classBeginTime,
			"classEndTime":   classEndTime,
			"location":       location,
			"planId":         planID,
			"planName":       planName,
			"teacherId":      teacherID,
			"teacherName":    teacherName,
			"hasEvaluated":   hasEvaluated,
		}

		scheduleMap[classDate] = append(scheduleMap[classDate], course)
		totalCourses++
	}

	// æ„å»ºè¿”å›æ•°æ®ï¼ˆåŒ…å«æ‰€æœ‰æ—¥æœŸï¼Œå³ä½¿æ²¡æœ‰è¯¾ç¨‹ï¼?
	schedule := []map[string]interface{}{}
	start, _ := time.Parse("2006-01-02", startDate)
	end, _ := time.Parse("2006-01-02", endDate)

	for d := start; !d.After(end); d = d.AddDate(0, 0, 1) {
		dateStr := d.Format("2006-01-02")
		courses := scheduleMap[dateStr]
		if courses == nil {
			courses = []map[string]interface{}{}
		}

		schedule = append(schedule, map[string]interface{}{
			"date":        dateStr,
			"courseCount": len(courses),
			"courses":     courses,
		})
	}

	// è¿”å›ç»“æœ
	c.JSON(http.StatusOK, gin.H{
		"code":    200,
		"message": "è·å–æˆåŠŸ",
		"data": gin.H{
			"startDate":    startDate,
			"endDate":      endDate,
			"totalCourses": totalCourses,
			"schedule":     schedule,
		},
	})
}

package employee

import (
	"backend/database"
	"net/http"

	"github.com/gin-gonic/gin"
)

// GetScores è·å–å‘˜å·¥æˆç»©åˆ—è¡¨
func GetScores(c *gin.Context) {
	// ä»ä¸­é—´ä»¶è·å–ç”¨æˆ·ID
	personID, exists := c.Get("personId")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"code": 401, "message": "æœªç™»å½?, "data": nil})
		return
	}

	// è·å–æŸ¥è¯¢å‚æ•°
	planID := c.Query("planId")
	courseClass := c.Query("courseClass")
	startDate := c.Query("startDate")
	endDate := c.Query("endDate")

	// æ„å»ºWHEREæ¡ä»¶
	whereConditions := "WHERE pe.person_id = ? AND pci.class_date < CURDATE()"
	params := []interface{}{personID}

	if planID != "" {
		whereConditions += " AND pci.plan_id = ?"
		params = append(params, planID)
	}
	if courseClass != "" {
		whereConditions += " AND c.course_class = ?"
		params = append(params, courseClass)
	}
	if startDate != "" {
		whereConditions += " AND pci.class_date >= ?"
		params = append(params, startDate)
	}
	if endDate != "" {
		whereConditions += " AND pci.class_date <= ?"
		params = append(params, endDate)
	}

	// æŸ¥è¯¢æˆç»©æ•°æ®
	query := `
		SELECT 
			pci.item_id,
			pci.course_id,
			c.course_name,
			c.course_desc,
			c.course_class,
			pci.class_date,
			pci.class_begin_time,
			pci.class_end_time,
			pci.location,
			pci.plan_id,
			tp.plan_name,
			c.teacher_id,
			p.name AS teacher_name,
			ae.self_score,
			ae.self_comment,
			ae.teacher_score,
			ae.teacher_comment,
			ae.score_ratio,
			CASE 
				WHEN ae.teacher_score IS NOT NULL THEN 
					ae.self_score * (1 - ae.score_ratio) + ae.teacher_score * ae.score_ratio
				ELSE NULL
			END AS weighted_score,
			CASE 
				WHEN ae.teacher_score IS NOT NULL THEN true
				ELSE false
			END AS has_teacher_score
		FROM plan_employee pe
		JOIN plan_course_item pci ON pe.plan_id = pci.plan_id
		JOIN course c ON pci.course_id = c.course_id
		JOIN training_plan tp ON pci.plan_id = tp.plan_id
		JOIN person p ON c.teacher_id = p.person_id
		LEFT JOIN attendance_evaluation ae ON ae.item_id = pci.item_id AND ae.person_id = ?
	` + whereConditions + `
		ORDER BY pci.class_date DESC
	`

	rows, err := database.DB.Raw(query, append([]interface{}{personID}, params...)...).Rows()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "æŸ¥è¯¢å¤±è´¥", "data": nil})
		return
	}
	defer rows.Close()

	// è§£æç»“æœ
	var scores []map[string]interface{}
	var totalCourses, completedCourses, pendingEvaluation int
	var sumScore, maxScore, minScore float64
	maxScore = 0
	minScore = 100

	for rows.Next() {
		var (
			itemID          int64
			courseID        int64
			courseName      string
			courseDesc      string
			courseClass     string
			classDate       string
			classBeginTime  string
			classEndTime    string
			location        string
			planID          int64
			planName        string
			teacherID       int64
			teacherName     string
			selfScore       *float64
			selfComment     *string
			teacherScore    *float64
			teacherComment  *string
			scoreRatio      *float64
			weightedScore   *float64
			hasTeacherScore bool
		)

		rows.Scan(
			&itemID, &courseID, &courseName, &courseDesc, &courseClass,
			&classDate, &classBeginTime, &classEndTime, &location,
			&planID, &planName, &teacherID, &teacherName,
			&selfScore, &selfComment, &teacherScore, &teacherComment,
			&scoreRatio, &weightedScore, &hasTeacherScore,
		)

		totalCourses++
		if selfScore != nil {
			completedCourses++
			if weightedScore != nil {
				sumScore += *weightedScore
				if *weightedScore > maxScore {
					maxScore = *weightedScore
				}
				if *weightedScore < minScore {
					minScore = *weightedScore
				}
			} else if selfScore != nil {
				sumScore += *selfScore
				if *selfScore > maxScore {
					maxScore = *selfScore
				}
				if *selfScore < minScore {
					minScore = *selfScore
				}
			}
		} else {
			pendingEvaluation++
		}

		score := map[string]interface{}{
			"itemId":          itemID,
			"courseId":        courseID,
			"courseName":      courseName,
			"courseDesc":      courseDesc,
			"courseClass":     courseClass,
			"classDate":       classDate,
			"classBeginTime":  classBeginTime,
			"classEndTime":    classEndTime,
			"location":        location,
			"planId":          planID,
			"planName":        planName,
			"teacherId":       teacherID,
			"teacherName":     teacherName,
			"selfScore":       selfScore,
			"selfComment":     selfComment,
			"teacherScore":    teacherScore,
			"teacherComment":  teacherComment,
			"scoreRatio":      scoreRatio,
			"weightedScore":   weightedScore,
			"hasTeacherScore": hasTeacherScore,
		}
		scores = append(scores, score)
	}

	// è®¡ç®—å¹³å‡åˆ?
	var averageScore float64
	if completedCourses > 0 {
		averageScore = sumScore / float64(completedCourses)
	}

	// å¦‚æœæ²¡æœ‰æˆç»©ï¼Œé‡ç½®æœ€å¤§æœ€å°å€?
	if completedCourses == 0 {
		maxScore = 0
		minScore = 0
	}

	// è¿”å›ç»“æœ
	c.JSON(http.StatusOK, gin.H{
		"code":    200,
		"message": "è·å–æˆåŠŸ",
		"data": gin.H{
			"statistics": gin.H{
				"totalCourses":      totalCourses,
				"completedCourses":  completedCourses,
				"pendingEvaluation": pendingEvaluation,
				"averageScore":      averageScore,
				"maxScore":          maxScore,
				"minScore":          minScore,
			},
			"scores": scores,
		},
	})
}

package employee

import (
	"backend/database"
	"backend/utils"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
)

// SubmitEvaluationRequest æäº¤è‡ªè¯„è¯·æ±‚ç»“æ„
type SubmitEvaluationRequest struct {
	ItemID        int64  `json:"itemId" binding:"required"`
	SelfComment   string `json:"selfComment" binding:"required,min=50,max=1000"`
	Understanding int    `json:"understanding"` // 1-5
	Difficulty    int    `json:"difficulty"`    // 1-5
	Satisfaction  int    `json:"satisfaction"`  // 1-5
}

// SubmitEvaluation æäº¤è¯¾ç¨‹è‡ªè¯„
func SubmitEvaluation(c *gin.Context) {
	// ä»ä¸­é—´ä»¶è·å–ç”¨æˆ·ID
	personID, exists := c.Get("personId")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"code": 401, "message": "æœªç™»å½?, "data": nil})
		return
	}

	// è§£æè¯·æ±‚
	var req SubmitEvaluationRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"code": 400, "message": "å‚æ•°é”™è¯¯ï¼? + err.Error(), "data": nil})
		return
	}

	// è®¾ç½®é»˜è®¤å€?
	if req.Understanding == 0 {
		req.Understanding = 3
	}
	if req.Difficulty == 0 {
		req.Difficulty = 3
	}
	if req.Satisfaction == 0 {
		req.Satisfaction = 3
	}

	// éªŒè¯è¯¾ç¨‹æ˜¯å¦å±äºè¯¥å‘˜å·?
	var count int64
	database.DB.Raw(`
		SELECT COUNT(*)
		FROM plan_employee pe
		JOIN plan_course_item pci ON pe.plan_id = pci.plan_id
		WHERE pe.person_id = ? AND pci.item_id = ?
	`, personID, req.ItemID).Scan(&count)

	if count == 0 {
		c.JSON(http.StatusForbidden, gin.H{"code": 403, "message": "æ— æƒé™ï¼šè¯¥è¯¾ç¨‹ä¸å±äºæ‚¨çš„è¯¾ç¨‹å®‰æ’", "data": nil})
		return
	}

	// æŸ¥è¯¢è¯¾ç¨‹ä¿¡æ¯
	var (
		courseID   int64
		courseName string
		classDate  string
	)
	err := database.DB.Raw(`
		SELECT pci.course_id, c.course_name, pci.class_date
		FROM plan_course_item pci
		JOIN course c ON pci.course_id = c.course_id
		WHERE pci.item_id = ?
	`, req.ItemID).Row().Scan(&courseID, &courseName, &classDate)

	if err != nil {
		c.JSON(http.StatusNotFound, gin.H{"code": 404, "message": "è¯¾ç¨‹ä¸å­˜åœ?, "data": nil})
		return
	}

	// éªŒè¯è¯¾ç¨‹æ˜¯å¦å·²ä¸Šå®?
	classDateParsed, _ := time.Parse("2006-01-02", classDate)
	if classDateParsed.After(time.Now()) || classDateParsed.Equal(time.Now().Truncate(24*time.Hour)) {
		c.JSON(http.StatusBadRequest, gin.H{"code": 400, "message": "è¯¾ç¨‹å°šæœªå¼€å§‹ï¼Œæš‚ä¸èƒ½è‡ªè¯?, "data": nil})
		return
	}

	// è°ƒç”¨AIç”Ÿæˆè¯„åˆ†
	selfScore, err := utils.GenerateEvaluationScore(
		req.SelfComment,
		req.Understanding,
		req.Difficulty,
		req.Satisfaction,
		courseName,
	)
	if err != nil {
		// AIè°ƒç”¨å¤±è´¥ï¼Œè®°å½•æ—¥å¿—ä½†ä¸ä¸­æ–­æµç¨?
		c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "AIè¯„åˆ†æœåŠ¡å¼‚å¸¸ï¼Œè¯·ç¨åé‡è¯•", "data": nil})
		return
	}

	// æŸ¥è¯¢æ˜¯å¦å·²æœ‰è¯„ä»·è®°å½•
	var existingID int64
	database.DB.Raw(`
		SELECT person_id 
		FROM attendance_evaluation 
		WHERE person_id = ? AND item_id = ?
	`, personID, req.ItemID).Scan(&existingID)

	// æ’å…¥æˆ–æ›´æ–°è¯„ä»·è®°å½?
	if existingID > 0 {
		// æ›´æ–°ç°æœ‰è®°å½•
		err = database.DB.Exec(`
			UPDATE attendance_evaluation 
			SET self_score = ?, self_comment = ?
			WHERE person_id = ? AND item_id = ?
		`, selfScore, req.SelfComment, personID, req.ItemID).Error
	} else {
		// æ’å…¥æ–°è®°å½•ï¼ˆscore_ratioé»˜è®¤ä¸?.5ï¼Œå³è‡ªè¯„å’Œè®²å¸ˆè¯„åˆ†å„å?0%ï¼?
		err = database.DB.Exec(`
			INSERT INTO attendance_evaluation 
			(person_id, item_id, self_score, self_comment, score_ratio) 
			VALUES (?, ?, ?, ?, 0.5)
		`, personID, req.ItemID, selfScore, req.SelfComment).Error
	}

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "ä¿å­˜å¤±è´¥", "data": nil})
		return
	}

	// æŸ¥è¯¢è®²å¸ˆè¯„åˆ†ï¼ˆå¦‚æœæœ‰ï¼?
	var teacherScore *float64
	var weightedScore *float64
	database.DB.Raw(`
		SELECT teacher_score,
			CASE 
				WHEN teacher_score IS NOT NULL THEN 
					self_score * (1 - score_ratio) + teacher_score * score_ratio
				ELSE NULL
			END AS weighted_score
		FROM attendance_evaluation 
		WHERE person_id = ? AND item_id = ?
	`, personID, req.ItemID).Row().Scan(&teacherScore, &weightedScore)

	// è¿”å›ç»“æœ
	c.JSON(http.StatusOK, gin.H{
		"code":    200,
		"message": "è‡ªè¯„æäº¤æˆåŠŸ",
		"data": gin.H{
			"itemId":        req.ItemID,
			"courseId":      courseID,
			"courseName":    courseName,
			"selfScore":     selfScore,
			"selfComment":   req.SelfComment,
			"teacherScore":  teacherScore,
			"weightedScore": weightedScore,
			"evaluatedAt":   time.Now().Format("2006-01-02 15:04:05"),
		},
	})
}

package employee

import (
	"backend/database"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
)

// GetTodayCourses è·å–å‘˜å·¥ä»Šæ—¥è¯¾ç¨‹åˆ—è¡¨
func GetTodayCourses(c *gin.Context) {
	// ä»ä¸­é—´ä»¶è·å–ç”¨æˆ·ID
	personID, exists := c.Get("personId")
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"code": 401, "message": "æœªç™»å½?, "data": nil})
		return
	}

	// è·å–ä»Šå¤©çš„æ—¥æœ?
	today := time.Now().Format("2006-01-02")

	// æŸ¥è¯¢ä»Šæ—¥è¯¾ç¨‹
	var courses []map[string]interface{}
	
	// SQLæŸ¥è¯¢ï¼šé€šè¿‡plan_employeeå…³è”æŸ¥æ‰¾è¯¥å‘˜å·¥ä»Šæ—¥çš„è¯¾ç¨‹
	rows, err := database.DB.Raw(`
		SELECT 
			pci.item_id,
			pci.course_id,
			c.course_name,
			c.course_desc,
			c.course_require,
			c.course_class,
			pci.class_date,
			pci.class_begin_time,
			pci.class_end_time,
			pci.location,
			pci.plan_id,
			tp.plan_name,
			c.teacher_id,
			p.name AS teacher_name,
			CASE 
				WHEN ae.person_id IS NOT NULL THEN true 
				ELSE false 
			END AS has_evaluated,
			CASE 
				WHEN pci.class_date < CURDATE() THEN 'å·²å®Œæˆ?
				WHEN pci.class_date = CURDATE() THEN 'å¾…ä¸Šè¯?
				ELSE 'å¾…ä¸Šè¯?
			END AS status
		FROM plan_employee pe
		JOIN plan_course_item pci ON pe.plan_id = pci.plan_id
		JOIN course c ON pci.course_id = c.course_id
		JOIN training_plan tp ON pci.plan_id = tp.plan_id
		JOIN person p ON c.teacher_id = p.person_id
		LEFT JOIN attendance_evaluation ae ON ae.item_id = pci.item_id AND ae.person_id = ?
		WHERE pe.person_id = ? AND DATE(pci.class_date) = ?
		ORDER BY pci.class_begin_time ASC
	`, personID, personID, today).Rows()

	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"code": 500, "message": "æŸ¥è¯¢å¤±è´¥", "data": nil})
		return
	}
	defer rows.Close()

	// è§£æç»“æœ
	for rows.Next() {
		var (
			itemID          int64
			courseID        int64
			courseName      string
			courseDesc      string
			courseRequire   string
			courseClass     string
			classDate       string
			classBeginTime  string
			classEndTime    string
			location        string
			planID          int64
			planName        string
			teacherID       int64
			teacherName     string
			hasEvaluated    bool
			status          string
		)

		rows.Scan(
			&itemID, &courseID, &courseName, &courseDesc, &courseRequire,
			&courseClass, &classDate, &classBeginTime, &classEndTime,
			&location, &planID, &planName, &teacherID, &teacherName,
			&hasEvaluated, &status,
		)

		course := map[string]interface{}{
			"itemId":         itemID,
			"courseId":       courseID,
			"courseName":     courseName,
			"courseDesc":     courseDesc,
			"courseRequire":  courseRequire,
			"courseClass":    courseClass,
			"classDate":      classDate,
			"classBeginTime": classBeginTime,
			"classEndTime":   classEndTime,
			"location":       location,
			"planId":         planID,
			"planName":       planName,
			"teacherId":      teacherID,
			"teacherName":    teacherName,
			"hasEvaluated":   hasEvaluated,
			"status":         status,
		}
		courses = append(courses, course)
	}

	// è¿”å›ç»“æœ
	c.JSON(http.StatusOK, gin.H{
		"code":    200,
		"message": "è·å–æˆåŠŸ",
		"data": gin.H{
			"date":        today,
			"courseCount": len(courses),
			"courses":     courses,
		},
	})
}

