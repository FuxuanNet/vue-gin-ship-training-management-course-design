后端与数据库技术栈验证
Gin 框架作为 Go 语言生态非常成熟的后端框架，支持高并发，性能优秀，之前我也用于写过两个网站的后端，技术可行。
数据库这里使用 gorm 库来与数据库进行连接，先是使用 SQLite 做技术验证，完全可行；之后又使用 MySQL 采用 Docker 部署，同样完全可行。
下面是 gorm 库与 SQLite 的对接：
```
package database

import (
    "log"
    "time"
    "gorm.io/driver/sqlite"
    "gorm.io/gorm"
)

// BaseModel 包含公共字段
type BaseModel struct {
    CreateTime time.Time `gorm:"autoCreateTime:true"` // 创建时间
    UpdateTime time.Time `gorm:"autoUpdateTime:true"` // 更新时间
}

// 定义数据库模型
// 管理员表 administrators
type Administrator struct {
    AdministratorId int64  `gorm:"primaryKey"` // 管理员ID(主键)
    Name            string // 姓名
}

var DB *gorm.DB

// InitDB 初始化数据库连接
func InitDB() error {
    db, err := gorm.Open(sqlite.Open("yuketang.db"), &gorm.Config{})
    if err != nil {
        return err
    }
    
    DB = db
    // 自动迁移表结构
    err = db.AutoMigrate(
        &Administrator{},
    )
    if err != nil {
        return err
    }

    log.Println("数据库初始化成功")
    return nil
}
```
下面是进行数据库的操作：
```
// 将user对象插入到数据库中
// 如果数据库中没有该用户，balance设为----，其余默认；如果有该用户，则
var existingUser database.User
database.DB.Where("user_id = ?", user.UserId).First(&existingUser)
if existingUser.UserId == 0 {
    user.Balance = int64(初始化金额变量) // 转换为int64类型
    mainlogger.Printf("输出日志")
    database.DB.Create(&user)
} else {
    // 保留用户原来的余额
    user.Balance = existingUser.Balance
    // 后面的内容省略不写
    database.DB.Save(&user)
}
```

下面是 gorm 库与 MySQL 的对接：

```
// 初始化数据库
func init() {
    dsn := "trustedspace:trustedspace123@tcp(localhost:3306)/trustedspace?charset=utf8mb4&parseTime=True&loc=Local"
    var err error

    // 设置标准Logger
    newLogger := logger.New(
        log.New(os.Stdout, "\r\n", log.LstdFlags), // 使用标准输出
        logger.Config{
            SlowThreshold: time.Second, // 慢SQL阈值
            LogLevel:      logger.Info, // 日志级别
            Colorful:      false,       // 禁用彩色日志
        },
    )

    // 连接数据库
    DB, err = gorm.Open(mysql.Open(dsn), &gorm.Config{
        Logger: newLogger,
    })

    if err != nil {
        util.LogError("数据库连接失败: %v", err)
        panic("数据库连接失败")
    }

    // 设置连接池
    sqlDB, err := DB.DB()
    if err != nil {
        util.LogError("获取数据库连接失败: %v", err)
        panic("获取数据库连接失败")
    }

    // 设置最大空闲连接数
    sqlDB.SetMaxIdleConns(10)
    // 设置最大打开连接数
    sqlDB.SetMaxOpenConns(100)
    // 设置连接的最大生命周期
    sqlDB.SetConnMaxLifetime(time.Hour)

    // 自动迁移数据表结构
    migrateDB()

    util.LogInfo("数据库连接成功")
}

```